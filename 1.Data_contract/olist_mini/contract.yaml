name: olist_mini
version: 0.1.0
owner:
  team: data-platform
  contacts:
    - name: Owner Example
      email: owner@example.com
lifecycle:
  status: draft
  created_at: 2025-08-13
  deprecation: none
refresh:
  cadence: daily
  sla_hours: 24
privacy:
  classification: internal

# Contract for Olist-like mini dataset
# Tables: customers, sellers, products, orders, order_items, order_payments, order_reviews

schemas:
  customers:
    description: Customers with city/state and a non-unique natural identifier
    primary_key: [customer_id]
    fields:
      customer_id: {type: string, required: true}
      customer_unique_id: {type: string, required: true}
      customer_zip_code_prefix: {type: integer, required: false}
      customer_city: {type: string, required: false}
      customer_state: {type: string, required: true, enum: [SP,RJ,MG,RS,PR,SC,BA,PE,CE,DF,GO,ES,PA,AM,RN,MT,MS,PB,MA]}
    expectations:
      - unique: [customer_id]
      - not_null: [customer_id, customer_unique_id, customer_state]

  sellers:
    description: Sellers location data
    primary_key: [seller_id]
    fields:
      seller_id: {type: string, required: true}
      seller_zip_code_prefix: {type: integer, required: true}
      seller_city: {type: string, required: true}
      seller_state: {type: string, required: true}
    expectations:
      - unique: [seller_id]
      - not_null: [seller_id, seller_zip_code_prefix, seller_city, seller_state]

  products:
    description: Product catalog with optional categories and physical dimensions
    primary_key: [product_id]
    fields:
      product_id: {type: string, required: true}
      product_category_name: {type: string, required: false}
      product_weight_g: {type: integer, required: false, min: 0}
      product_length_cm: {type: integer, required: false, min: 0}
      product_height_cm: {type: integer, required: false, min: 0}
      product_width_cm: {type: integer, required: false, min: 0}
    expectations:
      - unique: [product_id]

  orders:
    description: Orders lifecycle timestamps and status
    primary_key: [order_id]
    foreign_keys:
      - {field: customer_id, ref_table: customers, ref_field: customer_id}
    fields:
      order_id: {type: string, required: true}
      customer_id: {type: string, required: true}
      order_status: {type: string, required: true, enum: [delivered, shipped, invoiced, canceled, processing]}
      order_purchase_timestamp: {type: timestamp, required: true}
      order_approved_at: {type: timestamp, required: false}
      order_delivered_carrier_date: {type: timestamp, required: false}
      order_delivered_customer_date: {type: timestamp, required: false}
      order_estimated_delivery_date: {type: date, required: true}
    expectations:
      - unique: [order_id]
      - not_null: [order_id, customer_id, order_status, order_purchase_timestamp, order_estimated_delivery_date]
      - check: "(order_status in ['delivered','shipped']) -> order_delivered_customer_date is not null"
      - check: "order_delivered_customer_date >= order_delivered_carrier_date" # when both present
      - check: "order_approved_at >= order_purchase_timestamp" # when both present

  order_items:
    description: Items per order with price/freight and seller
    primary_key: [order_id, order_item_id]
    foreign_keys:
      - {field: order_id, ref_table: orders, ref_field: order_id}
      - {field: product_id, ref_table: products, ref_field: product_id}
      - {field: seller_id, ref_table: sellers, ref_field: seller_id}
    fields:
      order_id: {type: string, required: true}
      order_item_id: {type: integer, required: true}
      product_id: {type: string, required: true}
      seller_id: {type: string, required: true}
      shipping_limit_date: {type: timestamp, required: true}
      price: {type: decimal(10,2), required: true, min: 0}
      freight_value: {type: decimal(10,2), required: true}
    expectations:
      - unique: [order_id, order_item_id]
      - not_null: [order_id, order_item_id, product_id, seller_id, price, freight_value]
      - check: "price >= 0"
      - check: "freight_value >= 0" # allow negative only if modeling refunds explicitly

  order_payments:
    description: Payments per order, potentially multiple rows
    primary_key: [order_id, payment_sequential]
    foreign_keys:
      - {field: order_id, ref_table: orders, ref_field: order_id}
    fields:
      order_id: {type: string, required: true}
      payment_sequential: {type: integer, required: true}
      payment_type: {type: string, required: true, enum: [credit_card, boleto, voucher, debit_card, not_defined]}
      payment_installments: {type: integer, required: true, min: 1}
      payment_value: {type: decimal(10,2), required: true, min: 0}
    expectations:
      - unique: [order_id, payment_sequential]
      - not_null: [order_id, payment_sequential, payment_type, payment_installments, payment_value]

  order_reviews:
    description: Optional post-delivery reviews
    primary_key: [review_id]
    foreign_keys:
      - {field: order_id, ref_table: orders, ref_field: order_id}
    fields:
      review_id: {type: string, required: true}
      order_id: {type: string, required: true}
      review_score: {type: integer, required: true, min: 1, max: 5}
      review_comment_title: {type: string, required: false}
      review_comment_message: {type: string, required: false}
      review_creation_date: {type: timestamp, required: true}
      review_answer_timestamp: {type: timestamp, required: false}
    expectations:
      - unique: [review_id]
      - not_null: [review_id, order_id, review_score, review_creation_date]

# Cross-table expectations (logical, to be enforced downstream/GX)
checks:
  - name: payments_match_items
    description: Sum of order_items (price + freight) should roughly match sum of payments per order
    sql: |
      -- Example SQL to evaluate downstream (tolerance 1%):
      -- select o.order_id
      -- from orders o
      -- left join (
      --   select order_id, sum(price + freight_value) as items_total from order_items group by order_id
      -- ) i using(order_id)
      -- left join (
      --   select order_id, sum(payment_value) as payments_total from order_payments group by order_id
      -- ) p using(order_id)
      -- where abs(coalesce(i.items_total,0) - coalesce(p.payments_total,0)) > (0.01 * greatest(coalesce(i.items_total,0), 1));
